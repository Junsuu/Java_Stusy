## Chapter7 상속 (Inheritance)
> 주요 개념
> 1. 상속개념
> 2. 부모생성자 호출
> 3. 메소드 재정의(overwrite)
> 4. 상속에서의 final
> 5. protected 접근제한자
> 6.  타입변환과 다형성
> 7. 추상클래스

<br/>

#### 1. 상속 개념
>객체 지향 프로그래밍에서 부모 클래싀의 멤버를 자식클래스에 물려주는 행위로서 상위 클래스,  하위클래스(파생클래스) 라는 표현도 사용한다. 상속을 통해서 자식클래스는 부모 클래스의 필드 및 메소드를 활용 할 수 있다.

**사용법** : 자식 클래스 선언부에 `extends (상위클래스명)`을 선언 

<br/>

**상속을 사용하였을 때의 장점**

1. 코드의 중복 최소화
2. 재사용성을 높여줌
3. 부모클래스의 수정이 자식클래스에도 수정 효과를 가져와 유지 보수의 편리함

<br/>

**주의사항**

1. 부모클래스의 `private` 접근 제한을 갖는 필드와 메소드는 상속이 불가능
2. 부모 클래스와 자식 클래스가 다른 패키지에 존재할 경우 `default` 접근 제한을 갖는 필드와 메소드도 상속이 불가능
3. 다중 상속이 불가능하여 여러개의 `extends` 선언 불가능

-> 예제 코드 ( sampe1)

<br/>

#### 2. 부모 생성자 호출
>  자바에서 자식 객체 생성시 내부적으로 부모 객체가 먼저 생성되고 자식 객체가 그 다음에 생성된다.메모리 상으로 변수가 저장되는 스택 영역에 객체형태의 인스턴스 변수가 생성되었을때 그 변수는 힙 영역의 해당 자식 객체를 참조하고 있고, 그 자식 객체는 부모객체를 참조하고 있다.

모든 객체는 생성자를 호출해야 생성이 가능하다. 그렇다면 ***부모 객체의 생성자 호출은??***
-> **부모 객체의 생성자는 자식 생성자의 맨 첫줄에 호출된다!**
```
public class 자식객체 {
    public 자식객체생성자(){
        super();
    }
}
```
-> 명시적으로 선언하지 않았다면 컴파일러가 자동으로 부모 생성자 `super()`를 호출한다.

<br/>
**주의사항**

1. 매개값의 타입과 일치하는 부모 생성자 없을시 컴파일러 오류
2. 부모클래스 생성자에 기본생성자가 없고 매개변수가 필요한 생성자만 있다면 자식 생성자에서 명시적으로 `super()`를 통하여 생성해주어야 한다.
3.  부모생성자는 반드시 자식생성자의 첫줄에 위치하여야 한다.

-> 예제 코드(sample2)

<br/>

#### 3. 메소드 재정의
> 부모 클래스의 모든 메소드가 자식 클래스에 맞게 설계되어 있지 않는 경우 자식클래스에서 재정의 `@Override`를 통하여 수정하여 사용 가능하다.

메소드 오버라이딩을 하였을때 부모 객체의 메소드는 숨겨지기 때문에 자식객체에서 오버라이드한 메소드를 호출 시 자식 객체의 메소드가 호출된다.

```
class 부모객체 {
    void 메소드1();     //자식객체에서 재정의한 메소드 호출시 숨겨진다.
    void 메소드2();
}

class 자식객체 extends 부모객체 {
    @Override
    void 메소드1(){
        //재정의한 내용
    };
    void 메소드3();
}
```

<br/>

**오버라이드 규칙**

1. 부모 메소드와 동일한 시그니처(리턴타입, 메소드 이름, 매개변수 리스트)를 가져야한다.
2.  접근 제한을 더 강하게 할 수 없다.  ex) public -> default,private (x) <br/> BUT 반대로 약하게는 허용
3.  새로운 예외(Exception) 추가 불가능
4.  `@Override` 어노테이션은 생략이 가능하지만 어노테이션을 붙였을때 컴파일러가 체크해준다.

<br/>

**부모 클래스의 오버라이딩 된 메소드 호출 할때**

`super.메소드명()`을 통하여 부모 메소드 호출하며 
`super`는 부모객체를 참조하고 있기 때문에 부모 메소드에 직접적으로 접근이 가능하다.

-> 예제 코드(sample2)

<br/>

#### 4. fianl클래스와 Final 메소드
> final 키워드는 클래스, 필드, 메소드 선언에 이용 가능하며 final 키워드가 붙은 선언은 최종 상태임으로 더 이상 수정이 불가능 하다는 뜻이다.

1. 필드에 fianl 키워드 사용 시 <br> 초기값 선언후 필드 값 변경 불가능
2. 클래스에 fianl 키워드 사용 시<br/> 최종적인 클래스 상태로 상속이 불가능하기 때문에 부모클래스가 될 수 없다.(자식 클래스 생성 불가)  ex) `String 클래스`(상속 불가) 
3. 메소드에 fianl 키워드 사용 시 <br/> 최종적인 메소드로 오버라이딩 불가능 (자식 객체에서 오버라이딩 불가능)

-> 예제 코드(sample4)

<br/>

#### 5. protected 접근 제한자
> 필드, 생성자, 메소드에 선언이 가능하며 자식 클래스를 제외한 다른 패키지에 소속된 클래스는 접근이 불가능하다. `public` (중간 느낌)`default`<br/>
> 같은 패키지 내에서는 제한없이 접근이 가능하지만 다른 패키지에서는 자식클래스만 접근가능하다.

-> 예제 코드(sample5)

<br/>

#### 6. 타입 변환과 다형성
> ***다형성이란*** 타입은 같지만 실행결과가  다양한 객체를 이용할 수 있는 성질 <br/>
> 자바에서는 다형성을 위해서 부모 클래스로 타입 변환을 허용한다. 따라서 부모 타입에 모든 자식 객체가 대입가능하다. 이를 통해 객체를 부품화 할 수 있다.

클래스 타입의 변환은 상속 관계에 있는 클래스 사이에서 발생하며, 자식 타입은 부모 타입으로 **자동 타입 casting**이 가능하다.

<br/>

**자동 타입 casting**

개념 :자식은 부모의 특징과 기능을 상속 받기 때문에 부모와 동일하게 취급 가능하다.<br/>
-> 부모 타입으로 자동 캐스팅 된 경우에는 부모 클래스에 선언된 필드와 메소드에만 접근이 가능하다.<br/>

-> **예외**

자식클래스에서 오버라이딩 되었을때는 자식 클래스의 메소드가 대신 호출된다.(이유 : 부모객체의 메소드가 오버라이딩시 숨겨지기 때문에)

Smap<br/>

***DOWN Casting*** / ***UP Casting***

부모객체 A / 자식객체 A+B

자식객체는 부모객체 A의 모든 정보를 가지고 있음으로 Up casting이 가능하다. up casting 되었을때는 부모객체의 멤버에만 접근이 가능하다.

부모객체 A는 자식객체의 추가적인 정보 B를 가지고 있지 못함으로 Down Casting이 불가능하다. 강제 형변환 하였는때 컴파일러 체크는 통과 가능하다. 하지만 실행하였을때 런타임 exception을 뱉는다.

-> **예외**

 업캐스팅이 된 자식객체가 다시 다운캐스팅은 가능하다.

<br/>

**필드의 다형성을 사용하는 이유는???**

다형성이란 동일한 타입을 사용하지만 다양한 결과가 나오는 성질로 필드의 타입은 변함이 없지만 실행 도중에 어떤 객체의 필드로 저장하느냐에 따라 실행 결과가 달라질수 있는 점.
객체는 언제든지 다른 객체로 교체가 가능하여야 하며 이러한 성질을 위해 기존의 객체의 성질을 상속 받고 재정의 해서 사용한다.

<br/>

**매개변수의 다형성을 사용하는 이유는???**

매개값 다양화를 위해서 매개변수에 자식 타입 객체 지정이 가능하다. 매개변수의 타입이 클래스일 경우에 해당 클래스 객체 뿐만아니라 자식 클래스 객체까지 매개값으로 사용이 가능하다. 이때 자동으로 타입 변환이 발생한다. 따라서 어떤 자식 객체가 매개 값으로 오는가에 따라서 메소드의 실행결과가 다양해질 수 있다. 또한 자식 객체에서 오버라이딩한 메소드 사용 시 결과는 더욱 다양하게 나올 수 있다.

<br/>

**객체 타입 확인**(`instanceof`)

어떤 객체가 어떤 클래스의 인스턴스인지 확인하는 메소드로 연산자의 좌항에는 객체, 우항에는 타입이 온다. <br/>
- 좌항의 객체가 우항의 인스턴스이면(우항의 타입으로 객체가 생성시) `true`
- 좌항의 객체가 우항의 인스턴스가 아닐시(우항의 타입이 아닌 다른 인스턴스의 객체일때)`false`
- `instanceof`연산자는 주로 매개값의 타입을 조사할 때 사용한다.<br/>
-> 강제 타입 변환시 `instanceof`연산이 `true`일때 강제 형변환 진행<br/>
->**WHY?** 타입이 맞지 않으면 `ClassCastException`발생

```
// 형변환 전에 if 문을 통해서 강제 캐스팅이 가능한지 확인
public void method(부모객체 parent){
    if(parent instanceof 자식객체){
        자식객체 child = (Child) parent;
    }
}
```



#### 7. 추상 클래스

> **추상클래스 개념** <br/>
> **추상** : 실체간에 공통되는 특성을 추출한 것 ex) 새,곤충,물고기 -> 동물<br/>
> 실체들의 공통되는 특성을 가지고 있는 추상적인 개념<br/> 

**`JAVA Programmig`에서의 추상클래스란?** <br/>
실체 클래스의 공통적인 특성을 추출하여 선언한 클래스로 실체 클래스와 상속의 관계이다. 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있다.<br/>
추상 클래스는 실체 클래스의 공통 속성을 추출한 것이기 때문에 객체를 직접 생성하거나 인스턴스화 할 수 없다.(`new`연산자를 사용하여 인스턴스 생성 불가능!)

<br/>

**추상클래스의 용도**(핵심은 공통은 추상클래스로 빼고 다른점만 실체 클래스에 선ㅇ)
1. 실체 클래스들의 공통 필드와 메소드 이름 통일 시키기 위해서(협업시 이점)
2. 실체 클래스를 작성할 때 시간 절약(공통 필드와 메소드는 추상 클래스에 선언하고 다른점만 실체 클래스에 작성하여 시간 절약)(설계도면 역할)

**추상클래스 선언**

`abstract`키워드 사용하며 `new`연산자를 이용하여 객체 생성이 불가능하며 상속을 통해 자식 클래스만 생성이 가능하다.
```
public abstract class 클래스명 {
    //필드
    //생성자
    //메소드
}
```
추상클래스도 자식 객체가 생성될 때 `super()`를 통해 호출해서 추상 클래스 객체를 생성하므로 추상 클래스도 생성자가 필요하다!

<br/>

**추상 메소드 오버라이딩**

추상클래스는 실체 클래스가 공통으로 가져애할 필드와 메소드를 정의해놓으므로 실체 클래스의 멤버를 통일하는 목적을 가진다. 선언부만 통일하고 실행 내용이 달라야 하는 경우 추상클래스에서 추상 메소드를 통해 선언(선언부만 있고 실행내용 {}가 없는 메소드 ) -> 실체클래스에 특정 메소드의 실행부분을 채우도록 강제할 수 있다.(작성하지 않을시 컴파일 에러 발생)
<br/>
에시 ) 동물 추상클래스에서 sound() 메소드
```
[public / protected] abstract 리턴타입 메소드명(매개변수);
// 구현부 {} 존재 x
```
-> 예제코드()







<br/>

> 만들어야 하는 예제 목록
> 1. 기본상속 코드(자식 객체를 통해서 부모 객체 호출) ex) 290 
> 2. 부모 생성자 주의사항에 대하여 exception (3가지 exception) + 기본 ex) 294
> 3. Override 예제 (규칙 3개) ex) 297
> 4. 오버라이드 된 부모 메소드 호출 ex) 299
> 5. final 키워드 (클래스, 필드, 메소드) ex)301
> 6. protected 접근 제한자 예제(필드, 생성자, 메소드) ex) 305
> 7. 자동 캐스팅 + 강제캐스팅 + 업다운캐스팅(ex 308)
> 8. 다형성 (책참고)
> 9. 필드 다형성, 매개변수 다형성
> 10. instanceof 생성자 ex)328
> 11. 추상 클래스